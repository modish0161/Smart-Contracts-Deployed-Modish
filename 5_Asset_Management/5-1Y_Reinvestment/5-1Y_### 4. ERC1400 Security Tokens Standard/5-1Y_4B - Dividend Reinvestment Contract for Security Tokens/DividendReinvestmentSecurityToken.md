### Smart Contract: `DividendReinvestmentSecurityToken.sol`

This smart contract allows for automatic reinvestment of dividends generated by security tokens (e.g., tokenized stocks or bonds) into the same security token or a diversified portfolio of regulated assets. It leverages the ERC1400 standard, which is designed for security tokens with built-in compliance features.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/token/ERC1400/ERC1400.sol";

contract DividendReinvestmentSecurityToken is Ownable, ReentrancyGuard, Pausable {
    // ERC1400 Token Interface
    ERC1400 public securityToken;

    // Mapping to store user balances for each partition
    mapping(address => mapping(bytes32 => uint256)) public userTokenBalances;

    // Reinvestment Strategy for each user
    mapping(address => ReinvestmentStrategy) public reinvestmentStrategies;

    // Struct to define a reinvestment strategy
    struct ReinvestmentStrategy {
        bytes32[] partitions; // Token partitions to reinvest into
        uint256[] percentages; // Percentages for each partition
    }

    // Event declarations
    event DividendsDeposited(address indexed user, bytes32 partition, uint256 amount);
    event DividendsReinvested(address indexed user, uint256 totalAmount, bytes32[] partitions, uint256[] amounts);
    event ReinvestmentStrategyUpdated(address indexed user, bytes32[] partitions, uint256[] percentages);
    event SecurityTokenUpdated(address indexed tokenAddress);

    // Constructor to initialize the contract with the security token address
    constructor(address _securityToken) {
        require(_securityToken != address(0), "Invalid security token address");
        securityToken = ERC1400(_securityToken);
    }

    // Function to deposit dividends (ERC1400 tokens)
    function depositDividends(bytes32 partition, uint256 amount) external whenNotPaused nonReentrant {
        require(amount > 0, "Amount must be greater than zero");
        securityToken.operatorTransferByPartition(partition, msg.sender, address(this), amount, "", "");
        userTokenBalances[msg.sender][partition] += amount;

        emit DividendsDeposited(msg.sender, partition, amount);
    }

    // Function to set reinvestment strategy for the user
    function setReinvestmentStrategy(bytes32[] calldata partitions, uint256[] calldata percentages) external whenNotPaused {
        require(partitions.length == percentages.length, "Partitions and percentages length mismatch");
        uint256 totalPercentage = 0;
        for (uint256 i = 0; i < percentages.length; i++) {
            totalPercentage += percentages[i];
        }
        require(totalPercentage == 100, "Total percentage must equal 100");

        reinvestmentStrategies[msg.sender] = ReinvestmentStrategy({
            partitions: partitions,
            percentages: percentages
        });

        emit ReinvestmentStrategyUpdated(msg.sender, partitions, percentages);
    }

    // Function to reinvest dividends based on the user's strategy
    function reinvestDividends(bytes32 partition, uint256 amount) external whenNotPaused nonReentrant {
        require(userTokenBalances[msg.sender][partition] >= amount, "Insufficient balance for reinvestment");

        ReinvestmentStrategy memory strategy = reinvestmentStrategies[msg.sender];
        require(strategy.partitions.length > 0, "Reinvestment strategy not set");

        uint256 totalReinvested = 0;
        uint256[] memory reinvestAmounts = new uint256[](strategy.partitions.length);

        for (uint256 i = 0; i < strategy.partitions.length; i++) {
            uint256 reinvestAmount = (amount * strategy.percentages[i]) / 100;
            securityToken.operatorTransferByPartition(partition, address(this), msg.sender, reinvestAmount, "", "");
            reinvestAmounts[i] = reinvestAmount;
            totalReinvested += reinvestAmount;
        }

        userTokenBalances[msg.sender][partition] -= amount;

        emit DividendsReinvested(msg.sender, totalReinvested, strategy.partitions, reinvestAmounts);
    }

    // Function to update the security token address
    function updateSecurityToken(address newTokenAddress) external onlyOwner {
        require(newTokenAddress != address(0), "Invalid token address");
        securityToken = ERC1400(newTokenAddress);
        emit SecurityTokenUpdated(newTokenAddress);
    }

    // Function to pause the contract (admin only)
    function pause() external onlyOwner {
        _pause();
    }

    // Function to unpause the contract (admin only)
    function unpause() external onlyOwner {
        _unpause();
    }

    // Function to transfer ownership of the contract
    function transferOwnership(address newOwner) external onlyOwner {
        require(newOwner != address(0), "Invalid owner address");
        _transferOwnership(newOwner);
    }
}
```

### Key Features and Functionalities:

1. **Dividend Deposit and Reinvestment**:
   - `depositDividends()`: Allows users to deposit dividends in the form of ERC1400 security tokens with specific partitions.
   - `setReinvestmentStrategy()`: Allows users to set their reinvestment strategy by specifying partitions and percentages for each partition.
   - `reinvestDividends()`: Reinvests dividends into security tokens or partitions based on the user's predefined strategy.

2. **Reinvestment Strategy Management**:
   - Users can define their own reinvestment strategy by specifying partitions and the percentage of dividends to be reinvested into each partition.

3. **Administrative Controls**:
   - `updateSecurityToken()`: Allows the contract owner to update the security token address.
   - `pause()` and `unpause()`: Allows the contract owner to pause and resume contract operations for security or administrative reasons.

4. **Compliance Features**:
   - Supports ERC1400 compliance requirements such as partitions for regulated securities.
   - Reinforces KYC/AML checks through a whitelist (not currently implemented in this version but required for real-world deployment).

### Deployment Script

Create a deployment script using Hardhat:

```javascript
// scripts/deploy.js
async function main() {
  const [deployer] = await ethers.getSigners();
  const securityTokenAddress = "0x123..."; // Replace with actual security token address

  console.log("Deploying contracts with the account:", deployer.address);

  const DividendReinvestmentSecurityToken = await ethers.getContractFactory("DividendReinvestmentSecurityToken");
  const contract = await DividendReinvestmentSecurityToken.deploy(securityTokenAddress);

  console.log("DividendReinvestmentSecurityToken deployed to:", contract.address);
}

main()
  .then(() => process.exit(0))
  .catch(error => {
    console.error(error);
    process.exit(1);
  });
```

Run the deployment script using:

```bash
npx hardhat run scripts/deploy.js --network <network>
```

### Test Suite

Create a test suite for the contract:

```javascript
const { expect } = require("chai");

describe("DividendReinvestmentSecurityToken", function () {
  let DividendReinvestmentSecurityToken, contract, owner, addr1, addr2, securityToken;

  beforeEach(async function () {
    [owner, addr1, addr2] = await ethers.getSigners();

    // Mock ERC1400 token for testing
    const ERC1400Mock = await ethers.getContractFactory("ERC1400Mock");
    securityToken = await ERC1400Mock.deploy();

    DividendReinvestmentSecurityToken = await ethers.getContractFactory("DividendReinvestmentSecurityToken");
    contract = await DividendReinvestmentSecurityToken.deploy(securityToken.address);
    await contract.deployed();

    // Mint some tokens to addr1 for testing
    await securityToken.issueByPartition("0x01", addr1.address, 100, "");
    await securityToken.issueByPartition("0x02", addr1.address, 100, "");
  });

  it("Should allow user to deposit dividends", async function () {
    await securityToken.connect(addr1).operatorTransferByPartition("0x01", addr1.address, contract.address, 50, "", "");
    await contract.connect(addr1).depositDividends("0x01", 50);

    expect(await contract.userTokenBalances(addr1.address, "0x01")).to.equal(50);
  });

  it("Should allow user to set reinvestment strategy", async function () {
    await contract.connect(addr1).setReinvestmentStrategy(["0x01", "0x02"], [60, 40]);

    const strategy = await contract.reinvestmentStrategies(addr1.address);
    expect(strategy.partitions[0]).to.equal("0x01");
    expect(strategy.percentages[0]).to.equal(60);
  });

  it("Should reinvest dividends based on strategy", async function () {
    await securityToken.connect(addr1).operatorTransferByPartition("0x01", addr1.address, contract.address, 50, "", "");
    await contract.connect(addr1).depositDividends("0x01", 50);
    await contract.connect(addr1).setReinvestmentStrategy(["0x01", "0x02"], [60, 40]);

    await contract.connect(addr1).reinvestDividends("0x01", 30);

    expect(await contract.userTokenBalances(addr1.address, "0x01")).to.equal(20);
    expect(await securityToken.balanceOfByPartition("0x01", addr1.address)).to.equal(18); // 60% of 30
    expect(await securityToken.balanceOfByPartition("0x02", addr1.address)).to.equal(12); // 40% of 30
  });
});
```

Run the test suite using:

```

bash
npx hardhat test
```

### Additional Customizations

1. **KYC/AML Integration**: Add a whitelist to ensure only compliant investors can participate.
2. **Compliance Checks**: Implement compliance checks for each transaction.
3. **Oracle Integration**: Include oracles for dynamic adjustment of reinvestment strategies based on real-time data.
4. **Governance**: Add governance features for on-chain decision-making and parameter updates.

This contract provides a comprehensive solution for automatic reinvestment of dividends from security tokens while adhering to the ERC1400 standard.