### Smart Contract: `VaultReinvestmentContract.sol`

This smart contract implements the ERC4626 Tokenized Vault Standard. It automatically reinvests profits or yields generated by tokenized vaults into additional vault shares or other compliant assets. It ensures that earnings from pooled investments are compounded to maximize returns for participants.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC4626/ERC4626.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

contract VaultReinvestmentContract is Ownable, ReentrancyGuard, Pausable {
    using SafeMath for uint256;

    ERC4626 public vault;
    IERC20 public assetToken;
    mapping(address => uint256) public depositedShares;
    mapping(address => uint256) public reinvestmentPercentages;

    event Deposited(address indexed investor, uint256 amount, uint256 shares);
    event Withdrawn(address indexed investor, uint256 shares, uint256 amount);
    event Reinvested(address indexed investor, uint256 amount, uint256 shares);
    event ReinvestmentPercentageUpdated(address indexed investor, uint256 percentage);

    constructor(address _vaultAddress) {
        require(_vaultAddress != address(0), "Invalid vault address");
        vault = ERC4626(_vaultAddress);
        assetToken = IERC20(vault.asset());
    }

    // Deposit assets into the vault
    function deposit(uint256 amount) external whenNotPaused nonReentrant {
        require(amount > 0, "Amount must be greater than zero");
        require(assetToken.transferFrom(msg.sender, address(this), amount), "Transfer failed");

        // Approve and deposit into vault
        assetToken.approve(address(vault), amount);
        uint256 shares = vault.deposit(amount, address(this));
        
        depositedShares[msg.sender] = depositedShares[msg.sender].add(shares);

        emit Deposited(msg.sender, amount, shares);
    }

    // Withdraw assets from the vault
    function withdraw(uint256 shares) external whenNotPaused nonReentrant {
        require(depositedShares[msg.sender] >= shares, "Insufficient shares");

        depositedShares[msg.sender] = depositedShares[msg.sender].sub(shares);
        uint256 amount = vault.redeem(shares, msg.sender, address(this));

        emit Withdrawn(msg.sender, shares, amount);
    }

    // Set reinvestment percentage
    function setReinvestmentPercentage(uint256 percentage) external whenNotPaused {
        require(percentage <= 100, "Percentage cannot exceed 100");

        reinvestmentPercentages[msg.sender] = percentage;

        emit ReinvestmentPercentageUpdated(msg.sender, percentage);
    }

    // Reinvest profits based on reinvestment percentage
    function reinvestProfits() external whenNotPaused nonReentrant {
        uint256 totalShares = depositedShares[msg.sender];
        require(totalShares > 0, "No shares deposited");

        uint256 availableAssets = vault.previewRedeem(totalShares);
        uint256 reinvestmentAmount = availableAssets.mul(reinvestmentPercentages[msg.sender]).div(100);
        uint256 sharesToReinvest = vault.deposit(reinvestmentAmount, address(this));

        depositedShares[msg.sender] = depositedShares[msg.sender].add(sharesToReinvest);

        emit Reinvested(msg.sender, reinvestmentAmount, sharesToReinvest);
    }

    // Emergency withdraw all assets for the user
    function emergencyWithdraw() external nonReentrant {
        uint256 shares = depositedShares[msg.sender];
        require(shares > 0, "No shares to withdraw");

        depositedShares[msg.sender] = 0;
        uint256 amount = vault.redeem(shares, msg.sender, address(this));

        emit Withdrawn(msg.sender, shares, amount);
    }

    // Pause the contract in case of emergency
    function pause() external onlyOwner {
        _pause();
    }

    // Unpause the contract
    function unpause() external onlyOwner {
        _unpause();
    }

    // Update the vault address
    function updateVault(address newVaultAddress) external onlyOwner {
        require(newVaultAddress != address(0), "Invalid vault address");
        vault = ERC4626(newVaultAddress);
        assetToken = IERC20(vault.asset());
    }
}
```

### Key Features and Functionalities:

1. **Deposit and Withdraw**:
   - `deposit()`: Allows users to deposit assets into the vault, receiving vault shares in return.
   - `withdraw()`: Allows users to redeem their vault shares for the underlying assets, withdrawing from the vault.

2. **Reinvestment**:
   - `setReinvestmentPercentage()`: Users can set the percentage of their earnings to be reinvested automatically.
   - `reinvestProfits()`: Automatically reinvests profits based on the user's reinvestment percentage.

3. **Emergency Withdrawals**:
   - `emergencyWithdraw()`: Allows users to withdraw all their assets in case of an emergency.

4. **Contract Management**:
   - `pause()` and `unpause()`: Allows the contract owner to pause and resume contract operations for security or administrative reasons.
   - `updateVault()`: Allows the contract owner to update the vault address, enabling future upgrades.

5. **Security and Governance**:
   - Utilizes `Ownable`, `ReentrancyGuard`, and `Pausable` for enhanced security and administrative controls.

### Deployment Script

Create a deployment script using Hardhat:

```javascript
// scripts/deploy.js
async function main() {
  const [deployer] = await ethers.getSigners();
  const vaultAddress = "0x123..."; // Replace with actual vault address

  console.log("Deploying contracts with the account:", deployer.address);

  const VaultReinvestmentContract = await ethers.getContractFactory("VaultReinvestmentContract");
  const contract = await VaultReinvestmentContract.deploy(vaultAddress);

  console.log("VaultReinvestmentContract deployed to:", contract.address);
}

main()
  .then(() => process.exit(0))
  .catch(error => {
    console.error(error);
    process.exit(1);
  });
```

Run the deployment script using:

```bash
npx hardhat run scripts/deploy.js --network <network>
```

### Test Suite

Create a test suite for the contract:

```javascript
const { expect } = require("chai");

describe("VaultReinvestmentContract", function () {
  let VaultReinvestmentContract, contract, owner, addr1, vault, assetToken;

  beforeEach(async function () {
    [owner, addr1] = await ethers.getSigners();

    // Mock ERC4626 vault and asset token for testing
    const ERC20Mock = await ethers.getContractFactory("ERC20Mock");
    assetToken = await ERC20Mock.deploy("Test Asset", "TAS", 18);

    const ERC4626Mock = await ethers.getContractFactory("ERC4626Mock");
    vault = await ERC4626Mock.deploy(assetToken.address);

    VaultReinvestmentContract = await ethers.getContractFactory("VaultReinvestmentContract");
    contract = await VaultReinvestmentContract.deploy(vault.address);
    await contract.deployed();

    // Mint some tokens to addr1 for testing and approve
    await assetToken.mint(addr1.address, 1000);
    await assetToken.connect(addr1).approve(contract.address, 500);
  });

  it("Should allow user to deposit assets", async function () {
    await contract.connect(addr1).deposit(500);

    expect(await contract.depositedShares(addr1.address)).to.be.above(0);
  });

  it("Should allow user to set reinvestment percentage", async function () {
    await contract.connect(addr1).setReinvestmentPercentage(80);

    const percentage = await contract.reinvestmentPercentages(addr1.address);
    expect(percentage).to.equal(80);
  });

  it("Should allow user to reinvest profits", async function () {
    await contract.connect(addr1).deposit(500);
    await contract.connect(addr1).setReinvestmentPercentage(50);

    await contract.connect(addr1).reinvestProfits();

    expect(await contract.depositedShares(addr1.address)).to.be.above(0);
  });

  it("Should allow user to withdraw assets", async function () {
    await contract.connect(addr1).deposit(500);
    await contract.connect(addr1).withdraw(100);

    expect(await contract.depositedShares(addr1.address)).to.be.above(0);
  });

  it("Should allow emergency withdrawal", async function () {
    await contract.connect(addr1).deposit(500);
    await contract.connect(addr1).emergencyWithdraw();

    expect(await contract.depositedShares(addr1.address)).to.equal(0);
  });
});
```

Run the test suite using:

```bash
npx hardhat test
```

### Additional Customizations

1. **Automated Yield Reinvestment**: Integrate with yield farming strategies to automatically reinvest yields into higher-performing assets.
2. **Governance Features**: Implement on-chain governance for updating reinvestment strategies and compliance rules.
3. **Oracle Integration**: Include oracles for real-time data feed and compliance checks.
4. **DeFi Integration**: Support DeFi functionalities like staking, liquidity pooling, and cross-chain reinvestments.

This contract provides automated reinvestment into tokenized vaults, adhering to the ERC4626 standard, maximizing returns for participants through efficient asset management.